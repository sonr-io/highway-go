// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: v1/highway.proto

package highwayv1

import (
	context "context"
	bucket "go.buf.build/grpc/go/sonr-io/sonr/bucket"
	channel "go.buf.build/grpc/go/sonr-io/sonr/channel"
	object "go.buf.build/grpc/go/sonr-io/sonr/object"
	registry "go.buf.build/grpc/go/sonr-io/sonr/registry"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HighwayClient is the client API for Highway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HighwayClient interface {
	// Access a Name
	//
	// Returns details and publicly available information about the Peer given calling node
	// has permission to access.
	// i.e `prad.snr` -> "firstname online profilePic city"
	AccessName(ctx context.Context, in *MsgAccessName, opts ...grpc.CallOption) (*MsgAccessNameResponse, error)
	// Get a name
	//
	// Returns if a name has been taken in the system yet
	CheckName(ctx context.Context, in *MsgCheckName, opts ...grpc.CallOption) (*MsgCheckNameResponse, error)
	// Generate credentials
	//
	// Recieves client side JWT and attaches it to the users DID
	GenerateCreds(ctx context.Context, in *MsgWebToken, opts ...grpc.CallOption) (*MsgGenerateCredsResponse, error)
	// Register a Name
	//
	// Registers a new ".snr" name for the calling node. It is only allowed to be called
	// once per node.
	RegisterName(ctx context.Context, in *registry.MsgRegisterName, opts ...grpc.CallOption) (*registry.MsgRegisterNameResponse, error)
	// Update a Name
	//
	// Updates the public information of the calling node.
	UpdateName(ctx context.Context, in *registry.MsgUpdateName, opts ...grpc.CallOption) (*registry.MsgUpdateNameResponse, error)
	// Access a Service
	//
	// Creates a new signing key for the calling node in order to be authorized to
	// access the service. It is only allowed to be called once per node.
	AccessService(ctx context.Context, in *MsgAccessService, opts ...grpc.CallOption) (*MsgAccessServiceResponse, error)
	// Register a Service
	//
	// Registers a new service for the calling node. The calling node must have
	// already been enabled for development.
	RegisterService(ctx context.Context, in *registry.MsgRegisterService, opts ...grpc.CallOption) (*registry.MsgRegisterServiceResponse, error)
	// Update a Service
	//
	// Updates the details and public configuration of the calling node's service.
	UpdateService(ctx context.Context, in *registry.MsgUpdateService, opts ...grpc.CallOption) (*registry.MsgUpdateServiceResponse, error)
	// Create New Channel
	//
	// Creates a new Publish/Subscribe topic channel for the given service.
	// The calling node must have already registered a service for the channel.
	CreateChannel(ctx context.Context, in *channel.MsgCreateChannel, opts ...grpc.CallOption) (*channel.MsgCreateChannelResponse, error)
	// Read a Channel
	//
	// Lists all peers subscribed to the given channel, and additional details about
	// the channels configuration.
	ReadChannel(ctx context.Context, in *channel.MsgReadChannel, opts ...grpc.CallOption) (*channel.MsgReadChannelResponse, error)
	// Update a Channel
	//
	// Updates the configuration of the given channel.
	UpdateChannel(ctx context.Context, in *channel.MsgUpdateChannel, opts ...grpc.CallOption) (*channel.MsgUpdateChannelResponse, error)
	// Delete a Channel
	//
	// Deletes the given channel if the calling node is the owner of the channel.
	DeleteChannel(ctx context.Context, in *channel.MsgDeleteChannel, opts ...grpc.CallOption) (*channel.MsgDeleteChannelResponse, error)
	// Listen to a Channel
	//
	// Subscribes the calling node to the given channel and returns all publish events
	// as a stream.
	ListenChannel(ctx context.Context, in *MsgListenChannel, opts ...grpc.CallOption) (Highway_ListenChannelClient, error)
	// Create New Bucket
	//
	// Creates a new bucket for the calling nodes service.
	CreateBucket(ctx context.Context, in *bucket.MsgCreateBucket, opts ...grpc.CallOption) (*bucket.MsgCreateBucketResponse, error)
	// Read a Bucket
	//
	// Lists all the blobs in the given bucket. The calling node must have access to the
	// bucket.
	ReadBucket(ctx context.Context, in *bucket.MsgReadBucket, opts ...grpc.CallOption) (*bucket.MsgReadBucketResponse, error)
	// Update a Bucket
	//
	// Updates the configuration of the given bucket. The calling node must have access
	// to the bucket.
	UpdateBucket(ctx context.Context, in *bucket.MsgUpdateBucket, opts ...grpc.CallOption) (*bucket.MsgUpdateBucketResponse, error)
	// Delete a Bucket
	//
	// Deletes the given bucket if the calling node is the owner of the bucket.
	DeleteBucket(ctx context.Context, in *bucket.MsgDeleteBucket, opts ...grpc.CallOption) (*bucket.MsgDeleteBucketResponse, error)
	// Create New Object
	//
	// Defines a new object to be utilized by the calling node's service. The object will
	// be placed in the Highway Service Graph and can be used in channels and other modules.
	CreateObject(ctx context.Context, in *object.MsgCreateObject, opts ...grpc.CallOption) (*object.MsgCreateObjectResponse, error)
	// Read a Object
	//
	// Returns the details of the given object provided its DID or Label.
	ReadObject(ctx context.Context, in *object.MsgReadObject, opts ...grpc.CallOption) (*object.MsgReadObjectResponse, error)
	// Update a Object
	//
	// Modifies the property fields of the given object.
	UpdateObject(ctx context.Context, in *object.MsgUpdateObject, opts ...grpc.CallOption) (*object.MsgUpdateObjectResponse, error)
	// Delete a Object
	//
	// Deletes the given object if the calling node is the owner of the object.
	DeleteObject(ctx context.Context, in *object.MsgDeleteObject, opts ...grpc.CallOption) (*object.MsgDeleteObjectResponse, error)
	// Upload Blob
	//
	// Uploads a file or buffer to the calling node's service IPFS storage.
	UploadBlob(ctx context.Context, in *MsgUploadBlob, opts ...grpc.CallOption) (*MsgUploadBlobResponse, error)
	// Download a Blob
	//
	// Downloads a file or buffer from the calling node's service IPFS storage.
	DownloadBlob(ctx context.Context, in *MsgDownloadBlob, opts ...grpc.CallOption) (*MsgDownloadBlobResponse, error)
	// Synchronize Blob
	//
	// Synchronizes a local file from the calling node to the given service's IPFS storage.
	SyncBlob(ctx context.Context, in *MsgSyncBlob, opts ...grpc.CallOption) (*MsgSyncBlobResponse, error)
	// Delete a Blob
	//
	// Deletes the given blob from the calling node's service IPFS storage.
	DeleteBlob(ctx context.Context, in *MsgDeleteBlob, opts ...grpc.CallOption) (*MsgDeleteBlobResponse, error)
	// Parse a Did
	//
	// Parses a potential DID string into a DID object, using the calling node's network access.
	ParseDid(ctx context.Context, in *MsgParseDid, opts ...grpc.CallOption) (*MsgParseDidResponse, error)
	// Resolve Did
	//
	// Resolves a DID to its DID document if the DID is valid and the calling node has
	// access to the DID Document.
	ResolveDid(ctx context.Context, in *MsgResolveDid, opts ...grpc.CallOption) (*MsgResolveDidResponse, error)
}

type highwayClient struct {
	cc grpc.ClientConnInterface
}

func NewHighwayClient(cc grpc.ClientConnInterface) HighwayClient {
	return &highwayClient{cc}
}

func (c *highwayClient) AccessName(ctx context.Context, in *MsgAccessName, opts ...grpc.CallOption) (*MsgAccessNameResponse, error) {
	out := new(MsgAccessNameResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/AccessName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) CheckName(ctx context.Context, in *MsgCheckName, opts ...grpc.CallOption) (*MsgCheckNameResponse, error) {
	out := new(MsgCheckNameResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/CheckName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) GenerateCreds(ctx context.Context, in *MsgWebToken, opts ...grpc.CallOption) (*MsgGenerateCredsResponse, error) {
	out := new(MsgGenerateCredsResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/GenerateCreds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) RegisterName(ctx context.Context, in *registry.MsgRegisterName, opts ...grpc.CallOption) (*registry.MsgRegisterNameResponse, error) {
	out := new(registry.MsgRegisterNameResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/RegisterName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UpdateName(ctx context.Context, in *registry.MsgUpdateName, opts ...grpc.CallOption) (*registry.MsgUpdateNameResponse, error) {
	out := new(registry.MsgUpdateNameResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UpdateName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) AccessService(ctx context.Context, in *MsgAccessService, opts ...grpc.CallOption) (*MsgAccessServiceResponse, error) {
	out := new(MsgAccessServiceResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/AccessService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) RegisterService(ctx context.Context, in *registry.MsgRegisterService, opts ...grpc.CallOption) (*registry.MsgRegisterServiceResponse, error) {
	out := new(registry.MsgRegisterServiceResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/RegisterService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UpdateService(ctx context.Context, in *registry.MsgUpdateService, opts ...grpc.CallOption) (*registry.MsgUpdateServiceResponse, error) {
	out := new(registry.MsgUpdateServiceResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UpdateService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) CreateChannel(ctx context.Context, in *channel.MsgCreateChannel, opts ...grpc.CallOption) (*channel.MsgCreateChannelResponse, error) {
	out := new(channel.MsgCreateChannelResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/CreateChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ReadChannel(ctx context.Context, in *channel.MsgReadChannel, opts ...grpc.CallOption) (*channel.MsgReadChannelResponse, error) {
	out := new(channel.MsgReadChannelResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/ReadChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UpdateChannel(ctx context.Context, in *channel.MsgUpdateChannel, opts ...grpc.CallOption) (*channel.MsgUpdateChannelResponse, error) {
	out := new(channel.MsgUpdateChannelResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UpdateChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) DeleteChannel(ctx context.Context, in *channel.MsgDeleteChannel, opts ...grpc.CallOption) (*channel.MsgDeleteChannelResponse, error) {
	out := new(channel.MsgDeleteChannelResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/DeleteChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ListenChannel(ctx context.Context, in *MsgListenChannel, opts ...grpc.CallOption) (Highway_ListenChannelClient, error) {
	stream, err := c.cc.NewStream(ctx, &Highway_ServiceDesc.Streams[0], "/sonrio.highway.v1.Highway/ListenChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &highwayListenChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Highway_ListenChannelClient interface {
	Recv() (*channel.ChannelMessage, error)
	grpc.ClientStream
}

type highwayListenChannelClient struct {
	grpc.ClientStream
}

func (x *highwayListenChannelClient) Recv() (*channel.ChannelMessage, error) {
	m := new(channel.ChannelMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *highwayClient) CreateBucket(ctx context.Context, in *bucket.MsgCreateBucket, opts ...grpc.CallOption) (*bucket.MsgCreateBucketResponse, error) {
	out := new(bucket.MsgCreateBucketResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/CreateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ReadBucket(ctx context.Context, in *bucket.MsgReadBucket, opts ...grpc.CallOption) (*bucket.MsgReadBucketResponse, error) {
	out := new(bucket.MsgReadBucketResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/ReadBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UpdateBucket(ctx context.Context, in *bucket.MsgUpdateBucket, opts ...grpc.CallOption) (*bucket.MsgUpdateBucketResponse, error) {
	out := new(bucket.MsgUpdateBucketResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UpdateBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) DeleteBucket(ctx context.Context, in *bucket.MsgDeleteBucket, opts ...grpc.CallOption) (*bucket.MsgDeleteBucketResponse, error) {
	out := new(bucket.MsgDeleteBucketResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/DeleteBucket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) CreateObject(ctx context.Context, in *object.MsgCreateObject, opts ...grpc.CallOption) (*object.MsgCreateObjectResponse, error) {
	out := new(object.MsgCreateObjectResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/CreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ReadObject(ctx context.Context, in *object.MsgReadObject, opts ...grpc.CallOption) (*object.MsgReadObjectResponse, error) {
	out := new(object.MsgReadObjectResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/ReadObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UpdateObject(ctx context.Context, in *object.MsgUpdateObject, opts ...grpc.CallOption) (*object.MsgUpdateObjectResponse, error) {
	out := new(object.MsgUpdateObjectResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UpdateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) DeleteObject(ctx context.Context, in *object.MsgDeleteObject, opts ...grpc.CallOption) (*object.MsgDeleteObjectResponse, error) {
	out := new(object.MsgDeleteObjectResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/DeleteObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) UploadBlob(ctx context.Context, in *MsgUploadBlob, opts ...grpc.CallOption) (*MsgUploadBlobResponse, error) {
	out := new(MsgUploadBlobResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/UploadBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) DownloadBlob(ctx context.Context, in *MsgDownloadBlob, opts ...grpc.CallOption) (*MsgDownloadBlobResponse, error) {
	out := new(MsgDownloadBlobResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/DownloadBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) SyncBlob(ctx context.Context, in *MsgSyncBlob, opts ...grpc.CallOption) (*MsgSyncBlobResponse, error) {
	out := new(MsgSyncBlobResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/SyncBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) DeleteBlob(ctx context.Context, in *MsgDeleteBlob, opts ...grpc.CallOption) (*MsgDeleteBlobResponse, error) {
	out := new(MsgDeleteBlobResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/DeleteBlob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ParseDid(ctx context.Context, in *MsgParseDid, opts ...grpc.CallOption) (*MsgParseDidResponse, error) {
	out := new(MsgParseDidResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/ParseDid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *highwayClient) ResolveDid(ctx context.Context, in *MsgResolveDid, opts ...grpc.CallOption) (*MsgResolveDidResponse, error) {
	out := new(MsgResolveDidResponse)
	err := c.cc.Invoke(ctx, "/sonrio.highway.v1.Highway/ResolveDid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HighwayServer is the server API for Highway service.
// All implementations should embed UnimplementedHighwayServer
// for forward compatibility
type HighwayServer interface {
	// Access a Name
	//
	// Returns details and publicly available information about the Peer given calling node
	// has permission to access.
	// i.e `prad.snr` -> "firstname online profilePic city"
	AccessName(context.Context, *MsgAccessName) (*MsgAccessNameResponse, error)
	// Get a name
	//
	// Returns if a name has been taken in the system yet
	CheckName(context.Context, *MsgCheckName) (*MsgCheckNameResponse, error)
	// Generate credentials
	//
	// Recieves client side JWT and attaches it to the users DID
	GenerateCreds(context.Context, *MsgWebToken) (*MsgGenerateCredsResponse, error)
	// Register a Name
	//
	// Registers a new ".snr" name for the calling node. It is only allowed to be called
	// once per node.
	RegisterName(context.Context, *registry.MsgRegisterName) (*registry.MsgRegisterNameResponse, error)
	// Update a Name
	//
	// Updates the public information of the calling node.
	UpdateName(context.Context, *registry.MsgUpdateName) (*registry.MsgUpdateNameResponse, error)
	// Access a Service
	//
	// Creates a new signing key for the calling node in order to be authorized to
	// access the service. It is only allowed to be called once per node.
	AccessService(context.Context, *MsgAccessService) (*MsgAccessServiceResponse, error)
	// Register a Service
	//
	// Registers a new service for the calling node. The calling node must have
	// already been enabled for development.
	RegisterService(context.Context, *registry.MsgRegisterService) (*registry.MsgRegisterServiceResponse, error)
	// Update a Service
	//
	// Updates the details and public configuration of the calling node's service.
	UpdateService(context.Context, *registry.MsgUpdateService) (*registry.MsgUpdateServiceResponse, error)
	// Create New Channel
	//
	// Creates a new Publish/Subscribe topic channel for the given service.
	// The calling node must have already registered a service for the channel.
	CreateChannel(context.Context, *channel.MsgCreateChannel) (*channel.MsgCreateChannelResponse, error)
	// Read a Channel
	//
	// Lists all peers subscribed to the given channel, and additional details about
	// the channels configuration.
	ReadChannel(context.Context, *channel.MsgReadChannel) (*channel.MsgReadChannelResponse, error)
	// Update a Channel
	//
	// Updates the configuration of the given channel.
	UpdateChannel(context.Context, *channel.MsgUpdateChannel) (*channel.MsgUpdateChannelResponse, error)
	// Delete a Channel
	//
	// Deletes the given channel if the calling node is the owner of the channel.
	DeleteChannel(context.Context, *channel.MsgDeleteChannel) (*channel.MsgDeleteChannelResponse, error)
	// Listen to a Channel
	//
	// Subscribes the calling node to the given channel and returns all publish events
	// as a stream.
	ListenChannel(*MsgListenChannel, Highway_ListenChannelServer) error
	// Create New Bucket
	//
	// Creates a new bucket for the calling nodes service.
	CreateBucket(context.Context, *bucket.MsgCreateBucket) (*bucket.MsgCreateBucketResponse, error)
	// Read a Bucket
	//
	// Lists all the blobs in the given bucket. The calling node must have access to the
	// bucket.
	ReadBucket(context.Context, *bucket.MsgReadBucket) (*bucket.MsgReadBucketResponse, error)
	// Update a Bucket
	//
	// Updates the configuration of the given bucket. The calling node must have access
	// to the bucket.
	UpdateBucket(context.Context, *bucket.MsgUpdateBucket) (*bucket.MsgUpdateBucketResponse, error)
	// Delete a Bucket
	//
	// Deletes the given bucket if the calling node is the owner of the bucket.
	DeleteBucket(context.Context, *bucket.MsgDeleteBucket) (*bucket.MsgDeleteBucketResponse, error)
	// Create New Object
	//
	// Defines a new object to be utilized by the calling node's service. The object will
	// be placed in the Highway Service Graph and can be used in channels and other modules.
	CreateObject(context.Context, *object.MsgCreateObject) (*object.MsgCreateObjectResponse, error)
	// Read a Object
	//
	// Returns the details of the given object provided its DID or Label.
	ReadObject(context.Context, *object.MsgReadObject) (*object.MsgReadObjectResponse, error)
	// Update a Object
	//
	// Modifies the property fields of the given object.
	UpdateObject(context.Context, *object.MsgUpdateObject) (*object.MsgUpdateObjectResponse, error)
	// Delete a Object
	//
	// Deletes the given object if the calling node is the owner of the object.
	DeleteObject(context.Context, *object.MsgDeleteObject) (*object.MsgDeleteObjectResponse, error)
	// Upload Blob
	//
	// Uploads a file or buffer to the calling node's service IPFS storage.
	UploadBlob(context.Context, *MsgUploadBlob) (*MsgUploadBlobResponse, error)
	// Download a Blob
	//
	// Downloads a file or buffer from the calling node's service IPFS storage.
	DownloadBlob(context.Context, *MsgDownloadBlob) (*MsgDownloadBlobResponse, error)
	// Synchronize Blob
	//
	// Synchronizes a local file from the calling node to the given service's IPFS storage.
	SyncBlob(context.Context, *MsgSyncBlob) (*MsgSyncBlobResponse, error)
	// Delete a Blob
	//
	// Deletes the given blob from the calling node's service IPFS storage.
	DeleteBlob(context.Context, *MsgDeleteBlob) (*MsgDeleteBlobResponse, error)
	// Parse a Did
	//
	// Parses a potential DID string into a DID object, using the calling node's network access.
	ParseDid(context.Context, *MsgParseDid) (*MsgParseDidResponse, error)
	// Resolve Did
	//
	// Resolves a DID to its DID document if the DID is valid and the calling node has
	// access to the DID Document.
	ResolveDid(context.Context, *MsgResolveDid) (*MsgResolveDidResponse, error)
}

// UnimplementedHighwayServer should be embedded to have forward compatible implementations.
type UnimplementedHighwayServer struct {
}

func (UnimplementedHighwayServer) AccessName(context.Context, *MsgAccessName) (*MsgAccessNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessName not implemented")
}
func (UnimplementedHighwayServer) CheckName(context.Context, *MsgCheckName) (*MsgCheckNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckName not implemented")
}
func (UnimplementedHighwayServer) GenerateCreds(context.Context, *MsgWebToken) (*MsgGenerateCredsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCreds not implemented")
}
func (UnimplementedHighwayServer) RegisterName(context.Context, *registry.MsgRegisterName) (*registry.MsgRegisterNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterName not implemented")
}
func (UnimplementedHighwayServer) UpdateName(context.Context, *registry.MsgUpdateName) (*registry.MsgUpdateNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateName not implemented")
}
func (UnimplementedHighwayServer) AccessService(context.Context, *MsgAccessService) (*MsgAccessServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessService not implemented")
}
func (UnimplementedHighwayServer) RegisterService(context.Context, *registry.MsgRegisterService) (*registry.MsgRegisterServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterService not implemented")
}
func (UnimplementedHighwayServer) UpdateService(context.Context, *registry.MsgUpdateService) (*registry.MsgUpdateServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateService not implemented")
}
func (UnimplementedHighwayServer) CreateChannel(context.Context, *channel.MsgCreateChannel) (*channel.MsgCreateChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChannel not implemented")
}
func (UnimplementedHighwayServer) ReadChannel(context.Context, *channel.MsgReadChannel) (*channel.MsgReadChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadChannel not implemented")
}
func (UnimplementedHighwayServer) UpdateChannel(context.Context, *channel.MsgUpdateChannel) (*channel.MsgUpdateChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChannel not implemented")
}
func (UnimplementedHighwayServer) DeleteChannel(context.Context, *channel.MsgDeleteChannel) (*channel.MsgDeleteChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChannel not implemented")
}
func (UnimplementedHighwayServer) ListenChannel(*MsgListenChannel, Highway_ListenChannelServer) error {
	return status.Errorf(codes.Unimplemented, "method ListenChannel not implemented")
}
func (UnimplementedHighwayServer) CreateBucket(context.Context, *bucket.MsgCreateBucket) (*bucket.MsgCreateBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBucket not implemented")
}
func (UnimplementedHighwayServer) ReadBucket(context.Context, *bucket.MsgReadBucket) (*bucket.MsgReadBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadBucket not implemented")
}
func (UnimplementedHighwayServer) UpdateBucket(context.Context, *bucket.MsgUpdateBucket) (*bucket.MsgUpdateBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBucket not implemented")
}
func (UnimplementedHighwayServer) DeleteBucket(context.Context, *bucket.MsgDeleteBucket) (*bucket.MsgDeleteBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucket not implemented")
}
func (UnimplementedHighwayServer) CreateObject(context.Context, *object.MsgCreateObject) (*object.MsgCreateObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateObject not implemented")
}
func (UnimplementedHighwayServer) ReadObject(context.Context, *object.MsgReadObject) (*object.MsgReadObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadObject not implemented")
}
func (UnimplementedHighwayServer) UpdateObject(context.Context, *object.MsgUpdateObject) (*object.MsgUpdateObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateObject not implemented")
}
func (UnimplementedHighwayServer) DeleteObject(context.Context, *object.MsgDeleteObject) (*object.MsgDeleteObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObject not implemented")
}
func (UnimplementedHighwayServer) UploadBlob(context.Context, *MsgUploadBlob) (*MsgUploadBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadBlob not implemented")
}
func (UnimplementedHighwayServer) DownloadBlob(context.Context, *MsgDownloadBlob) (*MsgDownloadBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadBlob not implemented")
}
func (UnimplementedHighwayServer) SyncBlob(context.Context, *MsgSyncBlob) (*MsgSyncBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncBlob not implemented")
}
func (UnimplementedHighwayServer) DeleteBlob(context.Context, *MsgDeleteBlob) (*MsgDeleteBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBlob not implemented")
}
func (UnimplementedHighwayServer) ParseDid(context.Context, *MsgParseDid) (*MsgParseDidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseDid not implemented")
}
func (UnimplementedHighwayServer) ResolveDid(context.Context, *MsgResolveDid) (*MsgResolveDidResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveDid not implemented")
}

// UnsafeHighwayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HighwayServer will
// result in compilation errors.
type UnsafeHighwayServer interface {
	mustEmbedUnimplementedHighwayServer()
}

func RegisterHighwayServer(s grpc.ServiceRegistrar, srv HighwayServer) {
	s.RegisterService(&Highway_ServiceDesc, srv)
}

func _Highway_AccessName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAccessName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).AccessName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/AccessName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).AccessName(ctx, req.(*MsgAccessName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_CheckName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCheckName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).CheckName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/CheckName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).CheckName(ctx, req.(*MsgCheckName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_GenerateCreds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWebToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).GenerateCreds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/GenerateCreds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).GenerateCreds(ctx, req.(*MsgWebToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_RegisterName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(registry.MsgRegisterName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).RegisterName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/RegisterName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).RegisterName(ctx, req.(*registry.MsgRegisterName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UpdateName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(registry.MsgUpdateName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UpdateName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UpdateName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UpdateName(ctx, req.(*registry.MsgUpdateName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_AccessService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAccessService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).AccessService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/AccessService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).AccessService(ctx, req.(*MsgAccessService))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_RegisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(registry.MsgRegisterService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).RegisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/RegisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).RegisterService(ctx, req.(*registry.MsgRegisterService))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UpdateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(registry.MsgUpdateService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UpdateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UpdateService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UpdateService(ctx, req.(*registry.MsgUpdateService))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_CreateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(channel.MsgCreateChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).CreateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/CreateChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).CreateChannel(ctx, req.(*channel.MsgCreateChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ReadChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(channel.MsgReadChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).ReadChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/ReadChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).ReadChannel(ctx, req.(*channel.MsgReadChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UpdateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(channel.MsgUpdateChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UpdateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UpdateChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UpdateChannel(ctx, req.(*channel.MsgUpdateChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_DeleteChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(channel.MsgDeleteChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).DeleteChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/DeleteChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).DeleteChannel(ctx, req.(*channel.MsgDeleteChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ListenChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MsgListenChannel)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HighwayServer).ListenChannel(m, &highwayListenChannelServer{stream})
}

type Highway_ListenChannelServer interface {
	Send(*channel.ChannelMessage) error
	grpc.ServerStream
}

type highwayListenChannelServer struct {
	grpc.ServerStream
}

func (x *highwayListenChannelServer) Send(m *channel.ChannelMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Highway_CreateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bucket.MsgCreateBucket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).CreateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/CreateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).CreateBucket(ctx, req.(*bucket.MsgCreateBucket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ReadBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bucket.MsgReadBucket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).ReadBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/ReadBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).ReadBucket(ctx, req.(*bucket.MsgReadBucket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UpdateBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bucket.MsgUpdateBucket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UpdateBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UpdateBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UpdateBucket(ctx, req.(*bucket.MsgUpdateBucket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_DeleteBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(bucket.MsgDeleteBucket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).DeleteBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/DeleteBucket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).DeleteBucket(ctx, req.(*bucket.MsgDeleteBucket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_CreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(object.MsgCreateObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).CreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/CreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).CreateObject(ctx, req.(*object.MsgCreateObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ReadObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(object.MsgReadObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).ReadObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/ReadObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).ReadObject(ctx, req.(*object.MsgReadObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UpdateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(object.MsgUpdateObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UpdateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UpdateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UpdateObject(ctx, req.(*object.MsgUpdateObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_DeleteObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(object.MsgDeleteObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).DeleteObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/DeleteObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).DeleteObject(ctx, req.(*object.MsgDeleteObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_UploadBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUploadBlob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).UploadBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/UploadBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).UploadBlob(ctx, req.(*MsgUploadBlob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_DownloadBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDownloadBlob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).DownloadBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/DownloadBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).DownloadBlob(ctx, req.(*MsgDownloadBlob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_SyncBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncBlob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).SyncBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/SyncBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).SyncBlob(ctx, req.(*MsgSyncBlob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_DeleteBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteBlob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).DeleteBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/DeleteBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).DeleteBlob(ctx, req.(*MsgDeleteBlob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ParseDid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgParseDid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).ParseDid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/ParseDid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).ParseDid(ctx, req.(*MsgParseDid))
	}
	return interceptor(ctx, in, info, handler)
}

func _Highway_ResolveDid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgResolveDid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HighwayServer).ResolveDid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sonrio.highway.v1.Highway/ResolveDid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HighwayServer).ResolveDid(ctx, req.(*MsgResolveDid))
	}
	return interceptor(ctx, in, info, handler)
}

// Highway_ServiceDesc is the grpc.ServiceDesc for Highway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Highway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sonrio.highway.v1.Highway",
	HandlerType: (*HighwayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccessName",
			Handler:    _Highway_AccessName_Handler,
		},
		{
			MethodName: "CheckName",
			Handler:    _Highway_CheckName_Handler,
		},
		{
			MethodName: "GenerateCreds",
			Handler:    _Highway_GenerateCreds_Handler,
		},
		{
			MethodName: "RegisterName",
			Handler:    _Highway_RegisterName_Handler,
		},
		{
			MethodName: "UpdateName",
			Handler:    _Highway_UpdateName_Handler,
		},
		{
			MethodName: "AccessService",
			Handler:    _Highway_AccessService_Handler,
		},
		{
			MethodName: "RegisterService",
			Handler:    _Highway_RegisterService_Handler,
		},
		{
			MethodName: "UpdateService",
			Handler:    _Highway_UpdateService_Handler,
		},
		{
			MethodName: "CreateChannel",
			Handler:    _Highway_CreateChannel_Handler,
		},
		{
			MethodName: "ReadChannel",
			Handler:    _Highway_ReadChannel_Handler,
		},
		{
			MethodName: "UpdateChannel",
			Handler:    _Highway_UpdateChannel_Handler,
		},
		{
			MethodName: "DeleteChannel",
			Handler:    _Highway_DeleteChannel_Handler,
		},
		{
			MethodName: "CreateBucket",
			Handler:    _Highway_CreateBucket_Handler,
		},
		{
			MethodName: "ReadBucket",
			Handler:    _Highway_ReadBucket_Handler,
		},
		{
			MethodName: "UpdateBucket",
			Handler:    _Highway_UpdateBucket_Handler,
		},
		{
			MethodName: "DeleteBucket",
			Handler:    _Highway_DeleteBucket_Handler,
		},
		{
			MethodName: "CreateObject",
			Handler:    _Highway_CreateObject_Handler,
		},
		{
			MethodName: "ReadObject",
			Handler:    _Highway_ReadObject_Handler,
		},
		{
			MethodName: "UpdateObject",
			Handler:    _Highway_UpdateObject_Handler,
		},
		{
			MethodName: "DeleteObject",
			Handler:    _Highway_DeleteObject_Handler,
		},
		{
			MethodName: "UploadBlob",
			Handler:    _Highway_UploadBlob_Handler,
		},
		{
			MethodName: "DownloadBlob",
			Handler:    _Highway_DownloadBlob_Handler,
		},
		{
			MethodName: "SyncBlob",
			Handler:    _Highway_SyncBlob_Handler,
		},
		{
			MethodName: "DeleteBlob",
			Handler:    _Highway_DeleteBlob_Handler,
		},
		{
			MethodName: "ParseDid",
			Handler:    _Highway_ParseDid_Handler,
		},
		{
			MethodName: "ResolveDid",
			Handler:    _Highway_ResolveDid_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenChannel",
			Handler:       _Highway_ListenChannel_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/highway.proto",
}
