// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: registry/peer.proto

package types

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Internet Connection Type
type Connection int32

const (
	Connection_CONNECTION_UNSPECIFIED Connection = 0
	// ConnectionWifi is used for WiFi connections.
	Connection_CONNECTION_WIFI Connection = 1
	// ConnectionEthernet is used for Ethernet connections.
	Connection_CONNECTION_ETHERNET Connection = 2
	// ConnectionMobile is used for mobile connections.
	Connection_CONNECTION_MOBILE Connection = 3
	// CONNECTION_OFFLINE
	Connection_CONNECTION_OFFLINE Connection = 4
)

var Connection_name = map[int32]string{
	0: "CONNECTION_UNSPECIFIED",
	1: "CONNECTION_WIFI",
	2: "CONNECTION_ETHERNET",
	3: "CONNECTION_MOBILE",
	4: "CONNECTION_OFFLINE",
}

var Connection_value = map[string]int32{
	"CONNECTION_UNSPECIFIED": 0,
	"CONNECTION_WIFI":        1,
	"CONNECTION_ETHERNET":    2,
	"CONNECTION_MOBILE":      3,
	"CONNECTION_OFFLINE":     4,
}

func (x Connection) String() string {
	return proto.EnumName(Connection_name, int32(x))
}

func (Connection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{0}
}

// Peers Active Status
type Peer_Status int32

const (
	Peer_STATUS_UNSPECIFIED Peer_Status = 0
	Peer_STATUS_ONLINE      Peer_Status = 1
	Peer_STATUS_AWAY        Peer_Status = 2
	Peer_STATUS_BUSY        Peer_Status = 3
)

var Peer_Status_name = map[int32]string{
	0: "STATUS_UNSPECIFIED",
	1: "STATUS_ONLINE",
	2: "STATUS_AWAY",
	3: "STATUS_BUSY",
}

var Peer_Status_value = map[string]int32{
	"STATUS_UNSPECIFIED": 0,
	"STATUS_ONLINE":      1,
	"STATUS_AWAY":        2,
	"STATUS_BUSY":        3,
}

func (x Peer_Status) String() string {
	return proto.EnumName(Peer_Status_name, int32(x))
}

func (Peer_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{2, 0}
}

// Location from GeoIP and OLC information
type Location struct {
	// Location Latitude
	Latitude float64 `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// Location Longitude
	Longitude float64 `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// Location Placemark Information - Generated
	Placemark *Location_Placemark `protobuf:"bytes,3,opt,name=placemark,proto3" json:"placemark,omitempty"`
	// Last Updated Time
	LastModified int64 `protobuf:"varint,4,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{0}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Location) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Location) GetPlacemark() *Location_Placemark {
	if m != nil {
		return m.Placemark
	}
	return nil
}

func (m *Location) GetLastModified() int64 {
	if m != nil {
		return m.LastModified
	}
	return 0
}

// Contains detailed placemark information.
type Location_Placemark struct {
	// The name associated with the placemark.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The street associated with the placemark.
	Street string `protobuf:"bytes,2,opt,name=street,proto3" json:"street,omitempty"`
	// The abbreviated country name, according to the two letter (alpha-2) [ISO
	// standard](https://www.iso.org/iso-3166-country-codes.html).
	IsoCountryCode string `protobuf:"bytes,3,opt,name=iso_country_code,json=isoCountryCode,proto3" json:"iso_country_code,omitempty"`
	// The name of the country associated with the placemark.
	Country string `protobuf:"bytes,4,opt,name=country,proto3" json:"country,omitempty"`
	// The postal code associated with the placemark.
	PostalCode string `protobuf:"bytes,5,opt,name=postal_code,json=postalCode,proto3" json:"postal_code,omitempty"`
	// The name of the state or province associated with the placemark.
	AdministrativeArea string `protobuf:"bytes,6,opt,name=administrative_area,json=administrativeArea,proto3" json:"administrative_area,omitempty"`
	// Additional administrative area information for the placemark.
	SubAdministrativeArea string `protobuf:"bytes,7,opt,name=sub_administrative_area,json=subAdministrativeArea,proto3" json:"sub_administrative_area,omitempty"`
	// The name of the city associated with the placemark.
	Locality string `protobuf:"bytes,8,opt,name=locality,proto3" json:"locality,omitempty"`
	// Additional city-level information for the placemark.
	SubLocality string `protobuf:"bytes,9,opt,name=sub_locality,json=subLocality,proto3" json:"sub_locality,omitempty"`
	// The street address associated with the placemark.
	Thoroughfare string `protobuf:"bytes,10,opt,name=thoroughfare,proto3" json:"thoroughfare,omitempty"`
	// Additional street address information for the placemark.
	SubThoroughfare string `protobuf:"bytes,11,opt,name=sub_thoroughfare,json=subThoroughfare,proto3" json:"sub_thoroughfare,omitempty"`
}

func (m *Location_Placemark) Reset()         { *m = Location_Placemark{} }
func (m *Location_Placemark) String() string { return proto.CompactTextString(m) }
func (*Location_Placemark) ProtoMessage()    {}
func (*Location_Placemark) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{0, 0}
}
func (m *Location_Placemark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location_Placemark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location_Placemark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location_Placemark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location_Placemark.Merge(m, src)
}
func (m *Location_Placemark) XXX_Size() int {
	return m.Size()
}
func (m *Location_Placemark) XXX_DiscardUnknown() {
	xxx_messageInfo_Location_Placemark.DiscardUnknown(m)
}

var xxx_messageInfo_Location_Placemark proto.InternalMessageInfo

func (m *Location_Placemark) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Location_Placemark) GetStreet() string {
	if m != nil {
		return m.Street
	}
	return ""
}

func (m *Location_Placemark) GetIsoCountryCode() string {
	if m != nil {
		return m.IsoCountryCode
	}
	return ""
}

func (m *Location_Placemark) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *Location_Placemark) GetPostalCode() string {
	if m != nil {
		return m.PostalCode
	}
	return ""
}

func (m *Location_Placemark) GetAdministrativeArea() string {
	if m != nil {
		return m.AdministrativeArea
	}
	return ""
}

func (m *Location_Placemark) GetSubAdministrativeArea() string {
	if m != nil {
		return m.SubAdministrativeArea
	}
	return ""
}

func (m *Location_Placemark) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *Location_Placemark) GetSubLocality() string {
	if m != nil {
		return m.SubLocality
	}
	return ""
}

func (m *Location_Placemark) GetThoroughfare() string {
	if m != nil {
		return m.Thoroughfare
	}
	return ""
}

func (m *Location_Placemark) GetSubThoroughfare() string {
	if m != nil {
		return m.SubThoroughfare
	}
	return ""
}

// Shared Metadata for Messages on all Protocols
type Metadata struct {
	// Unix timestamp
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Node ID
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Signature of the message
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Public Key of the message sender
	PublicKey []byte `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{1}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Metadata) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *Metadata) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Metadata) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Basic Info Sent to Peers to Establish Connections
type Peer struct {
	SName        string       `protobuf:"bytes,1,opt,name=s_name,json=sName,proto3" json:"s_name,omitempty"`
	Status       Peer_Status  `protobuf:"varint,2,opt,name=status,proto3,enum=sonrio.sonr.registry.Peer_Status" json:"status,omitempty"`
	Device       *Peer_Device `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	Profile      *Profile     `protobuf:"bytes,4,opt,name=profile,proto3" json:"profile,omitempty"`
	PublicKey    []byte       `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PeerId       string       `protobuf:"bytes,6,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	LastModified int64        `protobuf:"varint,7,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{2}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetSName() string {
	if m != nil {
		return m.SName
	}
	return ""
}

func (m *Peer) GetStatus() Peer_Status {
	if m != nil {
		return m.Status
	}
	return Peer_STATUS_UNSPECIFIED
}

func (m *Peer) GetDevice() *Peer_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *Peer) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

func (m *Peer) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Peer) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *Peer) GetLastModified() int64 {
	if m != nil {
		return m.LastModified
	}
	return 0
}

// Peer Info for Device
type Peer_Device struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	Os       string `protobuf:"bytes,3,opt,name=os,proto3" json:"os,omitempty"`
	Arch     string `protobuf:"bytes,4,opt,name=arch,proto3" json:"arch,omitempty"`
	Model    string `protobuf:"bytes,5,opt,name=model,proto3" json:"model,omitempty"`
}

func (m *Peer_Device) Reset()         { *m = Peer_Device{} }
func (m *Peer_Device) String() string { return proto.CompactTextString(m) }
func (*Peer_Device) ProtoMessage()    {}
func (*Peer_Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{2, 0}
}
func (m *Peer_Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer_Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer_Device.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer_Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer_Device.Merge(m, src)
}
func (m *Peer_Device) XXX_Size() int {
	return m.Size()
}
func (m *Peer_Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Peer_Device proto.InternalMessageInfo

func (m *Peer_Device) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Peer_Device) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *Peer_Device) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *Peer_Device) GetArch() string {
	if m != nil {
		return m.Arch
	}
	return ""
}

func (m *Peer_Device) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// General Information about Peer passed during Authentication
type Profile struct {
	SName        string `protobuf:"bytes,1,opt,name=s_name,json=sName,proto3" json:"s_name,omitempty"`
	FirstName    string `protobuf:"bytes,2,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName     string `protobuf:"bytes,3,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Picture      []byte `protobuf:"bytes,4,opt,name=picture,proto3" json:"picture,omitempty"`
	Bio          string `protobuf:"bytes,6,opt,name=bio,proto3" json:"bio,omitempty"`
	LastModified int64  `protobuf:"varint,7,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_488b9a06cdfc1417, []int{3}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(m, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

func (m *Profile) GetSName() string {
	if m != nil {
		return m.SName
	}
	return ""
}

func (m *Profile) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Profile) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Profile) GetPicture() []byte {
	if m != nil {
		return m.Picture
	}
	return nil
}

func (m *Profile) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

func (m *Profile) GetLastModified() int64 {
	if m != nil {
		return m.LastModified
	}
	return 0
}

func init() {
	proto.RegisterEnum("sonrio.sonr.registry.Connection", Connection_name, Connection_value)
	proto.RegisterEnum("sonrio.sonr.registry.Peer_Status", Peer_Status_name, Peer_Status_value)
	proto.RegisterType((*Location)(nil), "sonrio.sonr.registry.Location")
	proto.RegisterType((*Location_Placemark)(nil), "sonrio.sonr.registry.Location.Placemark")
	proto.RegisterType((*Metadata)(nil), "sonrio.sonr.registry.Metadata")
	proto.RegisterType((*Peer)(nil), "sonrio.sonr.registry.Peer")
	proto.RegisterType((*Peer_Device)(nil), "sonrio.sonr.registry.Peer.Device")
	proto.RegisterType((*Profile)(nil), "sonrio.sonr.registry.Profile")
}

func init() { proto.RegisterFile("registry/peer.proto", fileDescriptor_488b9a06cdfc1417) }

var fileDescriptor_488b9a06cdfc1417 = []byte{
	// 849 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x41, 0x6f, 0xe2, 0x46,
	0x14, 0x8e, 0x31, 0x01, 0xfc, 0x60, 0x13, 0xef, 0x64, 0x93, 0xa0, 0xdd, 0x86, 0x66, 0xe9, 0x85,
	0x56, 0x2a, 0x48, 0xa9, 0xd4, 0xaa, 0x47, 0xc2, 0x82, 0x6a, 0x35, 0x81, 0xc8, 0x10, 0xad, 0xb6,
	0x17, 0x6b, 0xb0, 0x27, 0x30, 0x5a, 0xe3, 0xb1, 0x66, 0xc6, 0xab, 0x72, 0xe9, 0xad, 0xf7, 0x4a,
	0xfd, 0x1d, 0xfd, 0x1d, 0xed, 0x71, 0x8f, 0x3d, 0x56, 0xc9, 0x2f, 0xe8, 0x3f, 0xa8, 0x66, 0x3c,
	0x10, 0x92, 0x65, 0xab, 0x3d, 0xe1, 0xf7, 0xbd, 0xef, 0xf3, 0xbc, 0xf9, 0xde, 0x7b, 0x18, 0x0e,
	0x38, 0x99, 0x51, 0x21, 0xf9, 0xb2, 0x93, 0x12, 0xc2, 0xdb, 0x29, 0x67, 0x92, 0xa1, 0x67, 0x82,
	0x25, 0x9c, 0xb2, 0xb6, 0xfa, 0x69, 0xaf, 0x08, 0xcd, 0x3f, 0x8b, 0x50, 0xb9, 0x60, 0x21, 0x96,
	0x94, 0x25, 0xe8, 0x39, 0x54, 0x62, 0x2c, 0xa9, 0xcc, 0x22, 0x52, 0xb7, 0x4e, 0xad, 0x96, 0xe5,
	0xaf, 0x63, 0xf4, 0x19, 0x38, 0x31, 0x4b, 0x66, 0x79, 0xb2, 0xa0, 0x93, 0xf7, 0x00, 0x1a, 0x80,
	0x93, 0xc6, 0x38, 0x24, 0x0b, 0xcc, 0xdf, 0xd6, 0xed, 0x53, 0xab, 0x55, 0x3d, 0x6b, 0xb5, 0xb7,
	0x1d, 0xd8, 0x5e, 0x1d, 0xd6, 0xbe, 0x5a, 0xf1, 0xfd, 0x7b, 0x29, 0xfa, 0x02, 0x9e, 0xc4, 0x58,
	0xc8, 0x60, 0xc1, 0x22, 0x7a, 0x43, 0x49, 0x54, 0x2f, 0x9e, 0x5a, 0x2d, 0xdb, 0xaf, 0x29, 0xf0,
	0xd2, 0x60, 0xcf, 0x7f, 0xb7, 0xc1, 0x59, 0xab, 0x11, 0x82, 0x62, 0x82, 0x17, 0x79, 0xc1, 0x8e,
	0xaf, 0x9f, 0xd1, 0x11, 0x94, 0x84, 0xe4, 0x84, 0x48, 0x5d, 0xa9, 0xe3, 0x9b, 0x08, 0xb5, 0xc0,
	0xa5, 0x82, 0x05, 0x21, 0xcb, 0x12, 0xc9, 0x97, 0x41, 0xc8, 0x22, 0xa2, 0xab, 0x75, 0xfc, 0x3d,
	0x2a, 0x58, 0x2f, 0x87, 0x7b, 0x2c, 0x22, 0xa8, 0x0e, 0x65, 0xc3, 0xd2, 0x25, 0x38, 0xfe, 0x2a,
	0x44, 0x9f, 0x43, 0x35, 0x65, 0x42, 0xe2, 0x38, 0x97, 0xef, 0xea, 0x2c, 0xe4, 0x90, 0x96, 0x76,
	0xe0, 0x00, 0x47, 0x0b, 0x9a, 0xa8, 0xfb, 0x62, 0x49, 0xdf, 0x91, 0x00, 0x73, 0x82, 0xeb, 0x25,
	0x4d, 0x44, 0x0f, 0x53, 0x5d, 0x4e, 0x30, 0xfa, 0x16, 0x8e, 0x45, 0x36, 0x0d, 0xb6, 0x89, 0xca,
	0x5a, 0x74, 0x28, 0xb2, 0x69, 0xf7, 0x43, 0x9d, 0x6a, 0x17, 0x0b, 0x71, 0x4c, 0xe5, 0xb2, 0x5e,
	0xd1, 0xc4, 0x75, 0x8c, 0x5e, 0x42, 0x4d, 0xbd, 0x73, 0x9d, 0x77, 0x74, 0xbe, 0x2a, 0xb2, 0xe9,
	0xc5, 0x8a, 0xd2, 0x84, 0x9a, 0x9c, 0x33, 0xce, 0xb2, 0xd9, 0xfc, 0x06, 0x73, 0x52, 0x07, 0x4d,
	0x79, 0x80, 0xa1, 0x2f, 0xc1, 0x55, 0xaf, 0x79, 0xc0, 0xab, 0x6a, 0xde, 0xbe, 0xc8, 0xa6, 0x93,
	0x0d, 0xb8, 0xf9, 0x0b, 0x54, 0x2e, 0x89, 0xc4, 0x11, 0x96, 0x58, 0x0d, 0x8b, 0xa4, 0x0b, 0x22,
	0x24, 0x5e, 0xa4, 0xba, 0x31, 0xb6, 0x7f, 0x0f, 0xa0, 0x63, 0x28, 0x27, 0x2c, 0x22, 0x01, 0x8d,
	0x56, 0xed, 0x51, 0xa1, 0x17, 0x29, 0x99, 0xa0, 0xb3, 0x04, 0xcb, 0x8c, 0xe7, 0x7d, 0xa9, 0xf9,
	0xf7, 0x00, 0x3a, 0x01, 0x48, 0xb3, 0x69, 0x4c, 0xc3, 0xe0, 0x2d, 0xc9, 0xbb, 0x52, 0xf3, 0x9d,
	0x1c, 0xf9, 0x91, 0x2c, 0x9b, 0xff, 0xda, 0x50, 0xbc, 0x22, 0x84, 0xa3, 0x43, 0x28, 0x89, 0x60,
	0x63, 0x24, 0x76, 0xc5, 0x50, 0xcd, 0xc4, 0xf7, 0x6a, 0x26, 0xb0, 0xcc, 0x84, 0x3e, 0x74, 0xef,
	0xec, 0xe5, 0xf6, 0xf9, 0x54, 0xaf, 0x68, 0x8f, 0x35, 0xd1, 0x37, 0x02, 0x25, 0x8d, 0xc8, 0x3b,
	0x1a, 0x12, 0x33, 0xda, 0xff, 0x27, 0x7d, 0xa5, 0x89, 0xbe, 0x11, 0xa0, 0xef, 0xa0, 0x9c, 0x72,
	0x76, 0x43, 0x63, 0xa2, 0x2b, 0xae, 0x9e, 0x9d, 0x7c, 0x44, 0x9b, 0x93, 0xfc, 0x15, 0xfb, 0xd1,
	0x6d, 0x77, 0x1f, 0xdd, 0x56, 0x79, 0xa8, 0x76, 0x5b, 0x79, 0x98, 0x0f, 0x56, 0x49, 0x85, 0x5e,
	0xf4, 0xe1, 0x06, 0x95, 0xb7, 0x6c, 0x10, 0x83, 0x52, 0x5e, 0x27, 0xda, 0x83, 0x02, 0x8d, 0x8c,
	0x51, 0x05, 0x1a, 0xa1, 0x17, 0xe0, 0xcc, 0x99, 0x90, 0xb9, 0x7f, 0x79, 0x77, 0x2a, 0x0a, 0xd0,
	0x16, 0xee, 0x41, 0x81, 0x09, 0xb3, 0x30, 0x05, 0x26, 0xd4, 0xea, 0x61, 0x1e, 0xce, 0xcd, 0x86,
	0xe8, 0x67, 0xf4, 0x0c, 0x76, 0x17, 0x2c, 0x22, 0xb1, 0x59, 0x8c, 0x3c, 0x68, 0x5e, 0x43, 0x29,
	0xf7, 0x14, 0x1d, 0x01, 0x1a, 0x4f, 0xba, 0x93, 0xeb, 0x71, 0x70, 0x3d, 0x1c, 0x5f, 0xf5, 0x7b,
	0xde, 0xc0, 0xeb, 0xbf, 0x72, 0x77, 0xd0, 0x53, 0x78, 0x62, 0xf0, 0xd1, 0xf0, 0xc2, 0x1b, 0xf6,
	0x5d, 0x0b, 0xed, 0x43, 0xd5, 0x40, 0xdd, 0xd7, 0xdd, 0x37, 0x6e, 0x61, 0x03, 0x38, 0xbf, 0x1e,
	0xbf, 0x71, 0xed, 0xe6, 0x1f, 0x16, 0x94, 0x8d, 0x73, 0x1f, 0x6b, 0xfb, 0x09, 0xc0, 0x0d, 0xe5,
	0x0f, 0x6f, 0xe4, 0x68, 0x44, 0xa7, 0x5f, 0x80, 0xa3, 0xed, 0xd2, 0x59, 0xdb, 0x2c, 0x11, 0x36,
	0xc9, 0x3a, 0x94, 0x53, 0x1a, 0xea, 0x69, 0xcc, 0xc7, 0x6d, 0x15, 0x22, 0x17, 0xec, 0x29, 0x65,
	0xc6, 0x7a, 0xf5, 0xf8, 0x49, 0xbe, 0x7f, 0xf5, 0xab, 0x05, 0xd0, 0x63, 0x49, 0x42, 0x42, 0xf3,
	0x7f, 0x7b, 0xd4, 0x1b, 0x0d, 0x87, 0xfd, 0xde, 0xc4, 0x1b, 0x0d, 0x1f, 0xf9, 0x71, 0x00, 0xfb,
	0x1b, 0xb9, 0xd7, 0xde, 0xc0, 0x73, 0x2d, 0x74, 0x0c, 0x07, 0x1b, 0x60, 0x7f, 0xf2, 0x43, 0xdf,
	0x1f, 0xf6, 0x27, 0x6e, 0x01, 0x1d, 0xc2, 0xd3, 0x8d, 0xc4, 0xe5, 0xe8, 0xdc, 0xbb, 0xe8, 0xbb,
	0xb6, 0x32, 0x7b, 0x03, 0x1e, 0x0d, 0x06, 0xda, 0xd9, 0xe2, 0xf9, 0xf9, 0x5f, 0xb7, 0x0d, 0xeb,
	0xfd, 0x6d, 0xc3, 0xfa, 0xe7, 0xb6, 0x61, 0xfd, 0x76, 0xd7, 0xd8, 0x79, 0x7f, 0xd7, 0xd8, 0xf9,
	0xfb, 0xae, 0xb1, 0xf3, 0x53, 0x6b, 0x46, 0xe5, 0x3c, 0x9b, 0xb6, 0x43, 0xb6, 0xe8, 0xa8, 0x09,
	0xfd, 0x9a, 0x32, 0xfd, 0xdb, 0xf9, 0xb9, 0xb3, 0xfe, 0xa8, 0xc8, 0x65, 0x4a, 0xc4, 0xb4, 0xa4,
	0x3f, 0x2b, 0xdf, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x83, 0xa5, 0x7a, 0xd2, 0x6d, 0x06, 0x00,
	0x00,
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModified != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.LastModified))
		i--
		dAtA[i] = 0x20
	}
	if m.Placemark != nil {
		{
			size, err := m.Placemark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Location_Placemark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location_Placemark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location_Placemark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubThoroughfare) > 0 {
		i -= len(m.SubThoroughfare)
		copy(dAtA[i:], m.SubThoroughfare)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.SubThoroughfare)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Thoroughfare) > 0 {
		i -= len(m.Thoroughfare)
		copy(dAtA[i:], m.Thoroughfare)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Thoroughfare)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SubLocality) > 0 {
		i -= len(m.SubLocality)
		copy(dAtA[i:], m.SubLocality)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.SubLocality)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Locality) > 0 {
		i -= len(m.Locality)
		copy(dAtA[i:], m.Locality)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Locality)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SubAdministrativeArea) > 0 {
		i -= len(m.SubAdministrativeArea)
		copy(dAtA[i:], m.SubAdministrativeArea)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.SubAdministrativeArea)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AdministrativeArea) > 0 {
		i -= len(m.AdministrativeArea)
		copy(dAtA[i:], m.AdministrativeArea)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.AdministrativeArea)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PostalCode) > 0 {
		i -= len(m.PostalCode)
		copy(dAtA[i:], m.PostalCode)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PostalCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IsoCountryCode) > 0 {
		i -= len(m.IsoCountryCode)
		copy(dAtA[i:], m.IsoCountryCode)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.IsoCountryCode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Street) > 0 {
		i -= len(m.Street)
		copy(dAtA[i:], m.Street)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Street)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModified != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.LastModified))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Profile != nil {
		{
			size, err := m.Profile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPeer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SName) > 0 {
		i -= len(m.SName)
		copy(dAtA[i:], m.SName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.SName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Peer_Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer_Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer_Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Arch) > 0 {
		i -= len(m.Arch)
		copy(dAtA[i:], m.Arch)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Arch)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Os) > 0 {
		i -= len(m.Os)
		copy(dAtA[i:], m.Os)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Os)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModified != 0 {
		i = encodeVarintPeer(dAtA, i, uint64(m.LastModified))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Bio) > 0 {
		i -= len(m.Bio)
		copy(dAtA[i:], m.Bio)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Bio)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Picture) > 0 {
		i -= len(m.Picture)
		copy(dAtA[i:], m.Picture)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.Picture)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SName) > 0 {
		i -= len(m.SName)
		copy(dAtA[i:], m.SName)
		i = encodeVarintPeer(dAtA, i, uint64(len(m.SName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPeer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPeer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 9
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Placemark != nil {
		l = m.Placemark.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.LastModified != 0 {
		n += 1 + sovPeer(uint64(m.LastModified))
	}
	return n
}

func (m *Location_Placemark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Street)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.IsoCountryCode)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.PostalCode)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.AdministrativeArea)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.SubAdministrativeArea)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.SubLocality)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Thoroughfare)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.SubThoroughfare)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovPeer(uint64(m.Timestamp))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovPeer(uint64(m.Status))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.LastModified != 0 {
		n += 1 + sovPeer(uint64(m.LastModified))
	}
	return n
}

func (m *Peer_Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Arch)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Picture)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	l = len(m.Bio)
	if l > 0 {
		n += 1 + l + sovPeer(uint64(l))
	}
	if m.LastModified != 0 {
		n += 1 + sovPeer(uint64(m.LastModified))
	}
	return n
}

func sovPeer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPeer(x uint64) (n int) {
	return sovPeer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Placemark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Placemark == nil {
				m.Placemark = &Location_Placemark{}
			}
			if err := m.Placemark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			m.LastModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastModified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location_Placemark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Placemark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Placemark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsoCountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsoCountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostalCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostalCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdministrativeArea", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdministrativeArea = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAdministrativeArea", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubAdministrativeArea = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubLocality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubLocality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thoroughfare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thoroughfare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubThoroughfare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubThoroughfare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Peer_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Peer_Device{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			m.LastModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastModified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer_Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Picture", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Picture = append(m.Picture[:0], dAtA[iNdEx:postIndex]...)
			if m.Picture == nil {
				m.Picture = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPeer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPeer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			m.LastModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastModified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPeer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPeer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPeer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPeer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPeer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPeer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPeer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPeer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPeer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPeer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPeer = fmt.Errorf("proto: unexpected end of group")
)
